
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="ここからは、現実の開発で発生しがちなケースとその対応を検討してみます。 1.x-betaデバッグ中にリリースに含めるべき機能が追加される 「ねえねえ、今度リリース予定のバージョンなんだけど、作成中の○○の機能は入るの？」 「いや、その機能は次のリリースで追加される予定ですが」 「ええっ困るよ！ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://haiiro-shimeji.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:haiiro-shimeji.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/04/git-branch/">Git Branch</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-04T00:00:00+09:00" pubdate data-updated="true">Sep 4<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ここからは、現実の開発で発生しがちなケースとその対応を検討してみます。</p>

<h2>1.x-betaデバッグ中にリリースに含めるべき機能が追加される</h2>

<pre><code>「ねえねえ、今度リリース予定のバージョンなんだけど、作成中の○○の機能は入るの？」  
「いや、その機能は次のリリースで追加される予定ですが」  
「ええっ困るよ！まだデバッグ始まったばかりでしょ？今から○○も入れてリリースしてよ」  
「」
</code></pre>

<p>まだ1.xデバッグ中ということで、1.(x+1)は開発初期という可能性が高いです。</p>

<p>もし、該当のフィーチャーブランチがまだdevelopにマージされていなければ、フィーチャーブランチの開発が終わったら、developにマージせずに即時releaseにマージしてしまいましょう。すでにdevelopにマージ済みという場合は、上述のようにマージ段階のフィーチャーブランチの先頭コミットを調べて、それをreleaseにマージします。</p>

<pre><code>$ git log develop

commit e3d4e28365998b0d5f58b4e6c7b8f7e5cc68349e
Merge: 3804264 a1d81d8
Author: ikeda.shoichi &lt;ikeda.shoichi@localhost&gt;
Date:   2015-09-02 14:09:22 +0900

    Merge branch 'newFeatureA' into develop

$ git checkout release
$ git merge a1d81d8 --no-ff
</code></pre>

<p>その後、releaseをdevelopにマージします。該当機能に関するバグフィックスなどが発生したら、他のreleaseで修正されるバグと同様に、releaseにコミットしてdevelopにマージします。</p>

<p>1.(x+1)が開発初期ということで、フィーチャーブランチをreleaseにマージする際に衝突は発生しない場合が多いでしょう。しないといいですね。衝突してしまった場合はかなり面倒な作業でコミットの切り分けをする必要があります。本質的には次項と同じなので、そちらを参照してください。</p>

<h2>当初予定されていた機能を削ったバージョンを前倒しでリリースすることになった</h2>

<pre><code>「ねえねえ、○○の機能が入る次のバージョンっていつリリースなの？」  
「△月の予定ですが」  
「遠いなあ…○○をすぐに使いたいっていうお客さんがいるから、○○だけ入れて前倒しでリリースしてよ」  
「」
</code></pre>

<p>ほとんど最悪な状況なのですが、実際にはよく起こります。世の中の人は、機能どうしの依存関係などは考慮に入れることなく、単純な足し算引き算で機能の着脱、納期の伸縮が可能であると思っています。</p>

<p>バージョン1.xとして複数の機能を開発している途中で、そのなかのひとつだけを実装に含めてreleaseブランチを作成し、リリース作業を開始することになります。</p>

<p>まず、前回リリース時のreleaseブランチを復活させ、次回リリースに使うreleaseブランチとします。前回リリース時のreleaseブランチは、masterへのマージログから参照することが出来ます。</p>

<pre><code>$ git log master
commit 017a9a034d8d2be74a72563b69e370ee9188bb26
Merge: ec2ecd9 da06717
Author: ikeda.shoichi &lt;ikeda.shoichi@localhost&gt;
Date:   2015-09-02 06:01:59 +0900

    Merge branch 'release' into master

$ git checkout da06717
$ git checkout -b release
</code></pre>

<p>そこに該当機能のフィーチャーブランチをマージして新しいバージョンのリリース作業を開始します。<br/>
マージ時に運良く衝突が発生しなければラッキーですが、衝突してしまった場合は、developブランチ上で該当のフィーチャーブランチがマージされるまでの間にされたコミットのうち、このブランチが依存するものだけを選択してreleaseブランチにcherry-pickしていく必要があります。ここまでの開発で、適切なコミット粒度を維持できていたかが問われます。releaseに首尾よくマージできても、developに再度マージする際にも多分衝突が発生します。あきらめずにがんばりましょう。</p>

<h2>後方互換性の無いバージョン2.0の開発と1.xの開発に分化する</h2>

<p>「ねえねえ、次のバージョンではP○P 5.1のサポートを切るって聞いたけど」
「はい、もうセキュリティ上の理由で古いバージョンは使われないと判断しました。その場合、古いバージョンで許される記述のみで開発を続けるのは、開発コスト的にも高くなるので」
「お客さんのサーバーで、事情があってP○Pのバージョンを上げられないところがあって、古いバージョンでも動く形で、バグフィックスとかだけ適用していって欲しいんだけど」
「」</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/02/git-flow/">Gitのブランチ運用とgit Flow</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-02T00:00:00+09:00" pubdate data-updated="true">Sep 2<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>gitでのブランチ運用においてよく使われるモデルに、&#8221;A successful Git branching model&#8221;というのがあります。</p>

<p>http://keijinsonyaban.blogspot.jp/2010/10/successful-git-branching-model.html<br/>
に邦訳があるので詳細についてはこちらを読んでいただくとよいと思うのですが、かいつまんで言うと
、プログラムに発生する修正を以下の3つに分けて異なるブランチで管理するというものです。</p>

<ul>
<li>リリース済み製品に対して迅速に修正するべきバグの修正</li>
<li>リリースにあたっての安定動作のためのバグ修正</li>
<li>機能追加</li>
</ul>


<p>これらの修正は互いに求められる信頼度が異なるため、区別なく扱われてしまうとソフトウェア全体の信頼度として期待する状態でのリリースが難しくなります。このために、各々の修正を適用するブランチを区別し適宜マージを繰り返しながらリリースを行っていくのが、このモデルの基本的なブランチの運用になります。</p>

<p>この &#8220;A successful Git branching model&#8221; の運用をサポートするのが、git-flowになります。<br/>
ここでは、GitのGUIクライアントである SourceTree を使って、実際のユースケースに則してgit-flowおよび &#8220;A successful Git branching model&#8221; の運用を解説します。<br/>
しかし、じつはこのモデル運用にgit-flowは必須ではありません。git-flowは複数のgitコマンドをモデル運用に適するようにマクロ化したもので、それを普通のgitで行ったとしても、それほど複雑ではなく十分可能です。<br/>
以下の記述では、git-flowを使わずに操作する場合も考慮して各々の操作において内部的に何を行っているのかとブランチの状況などを適宜図示していきます。</p>

<h1>運用手順</h1>

<h2>git flow の初期化</h2>

<p>まずは、git-flowの初期化を行います。ウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックします。<br/>
これは、開発の一番最初に行うべきですが、すでにmaster上である程度初期開発を行ったあとで初期化しても全く問題はありません。</p>

<p><img src="/images/2015-09-02-git-flow-init.png" alt="git flow init" /></p>

<p>すると、下のようなダイアログが現れます。すべてデフォルト値で問題ないので、&#8221;OK&#8221;をクリックします。</p>

<p><img src="/images/2015-09-02-git-flow-init-dialog.png" alt="git flow init dialog" /></p>

<p>ブランチ&#8221;develop&#8221;が作成され、現在のブランチがdevelopに切り替わります。また、.git/configにこの設定ダイアログで指定したブランチ名とブランチ名プレフィックスが書き込まれ、今後のgit-flow操作で参照されるようになります。</p>

<p><img src="/images/2015-09-02-git-flow-init-result.png" alt="git flow init result" /></p>

<p>この後は、開発は基本的にdevelopで行うこととし、masterはリリース済みのコミットが蓄積されていくことになります。</p>

<h2>フィーチャーブランチの作成</h2>

<p>機能開発は、フィーチャーブランチ上で行います。ウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックします。<br/>
下のようなダイアログが現れるので、&#8221;新規フィーチャーを開始&#8221;をクリックします。</p>

<p><img src="/images/2015-09-02-git-flow-feature-start.png" alt="git flow feature start" /></p>

<p>これからこのフィーチャーブランチ上で開発する機能を端的に表す名前を入力し、&#8221;OK&#8221;をクリックします。</p>

<p><img src="/images/2015-09-02-git-flow-feature-start-name.png" alt="git flow feature start name" /></p>

<p>これで、機能開発用のフィーチャーブランチ&#8221;feature/newFeatureA&#8221;が作成され、現在のブランチが移動します。機能開発は、複数人開発では一般的に並行して行われます。フィーチャーブランチは複数同時に作成され、別個に進行していきます。</p>

<p><img src="/images/2015-09-02-git-flow-feature-branches.png" alt="git flow feature branches" /></p>

<h2>フィーチャーブランチのマージ</h2>

<p>機能開発が完了したら、フィーチャーブランチを終了しdevelopにマージします。フィーチャーブランチ上でウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックします。下のようなダイアログが現れるので、&#8221;現在のブランチを終了&#8221;をクリックします。</p>

<p><img src="/images/2015-09-02-git-flow-feature-finish.png" alt="git flow feature finish" /></p>

<p>下のようなダイアログが現れるので、&#8221;OK&#8221;をクリックします。</p>

<p><img src="/images/2015-09-02-git-flow-feature-finish-dialog.png" alt="git flow feature finish dialog" /></p>

<p>この操作では、フィーチャーブランチのdevelopへのマージと、それが成功すればdevelopへの移動、フィーチャーブランチの削除を行います。<br/>
しかし、通常はすんなりマージされるのですが、当然競合が発生する可能性もあります。今回は、newFeatureAのマージ前に別のnewFeatureBのマージを行っておき、競合が発生する変更を用意しておきました。</p>

<p><img src="/images/2015-09-02-git-flow-feature-finish-conflict.png" alt="git flow feature finish conflict" /></p>

<p>競合を解消し、コミットします。グラフは下のようになります。</p>

<p><img src="/images/2015-09-02-git-flow-feature-finish-graph.png" alt="git flow feature finish graph" /></p>

<p>&#8220;現在のブランチを終了&#8221;すると、通常はそのままブランチは削除されますが、衝突が発生した場合はマージ後もブランチが残るので、手動で削除する必要があります。</p>

<h2>フィーチャーブランチの継続開発</h2>

<p>フィーチャーブランチを一旦マージした後、またすぐに修正する必要が発生したとします。一機能に対する修正はできるだけひとつのフィーチャーブランチにまとめたほうがいいので、先ほどマージしたフィーチャーブランチを復活させて再度修正してみます。</p>

<p>マージしたブランチのHEADは、マージコミットの中に記録されています。このコミットから再度ブランチを作成します。</p>

<p><img src="/images/2015-09-02-git-flow-feature-finish-remake.png" alt="git flow feature finish remake" /></p>

<p>ウィンドウ上部ツールバーの「ブランチ」をクリックします。ブランチ設定ウィンドウが現れるので、下のように入力します。ブランチ名には削除する前の&#8221;feature/newFeatureA&#8221;を指定(別の名称でもいいのですが、機能の開発を継続するという意味で同じ名前にします)、「指定のコミット」に指定するコミットは、先ほどコミットログから確認したコミットを選択してください。</p>

<p><img src="/images/2015-09-02-git-branch.png" alt="git flow feature finish remake" /></p>

<p>その後、フィーチャーブランチ上でさらに開発し、ふたたび「ブランチの終了」によってマージすると下のようになります。</p>

<p><img src="/images/2015-09-02-git-flow-feature-remerge-graph.png" alt="git flow feature remerge graph" /></p>

<h2>リリース工程</h2>

<p>必要な機能の開発がひととおり終了し、リリースの準備に入るとします。<br/>
リリースの際は検証工程(テスト)を行い、バグ修正を行う必要があります。この期間にもし別のメンバーによって(今回のリリースには入らない)新機能が追加されてしまうと、リリースされるプロダクトに求められる信頼度に至らないコードが混入してしまうことになります。<br/>
これを避けるために、リリース工程用のブランチを切って、ここでデバッグと修正作業を行います。</p>

<p>ウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックします。現れたウィンドウで「新規リリースを開始」をクリックします。下のようなダイアログが現れるので、「リリースバージョン」に今回のリリースバージョンを入力します。</p>

<p><img src="/images/2015-09-02-git-flow-release-start.png" alt="git flow release start" /></p>

<p>この操作で、リリースブランチrelease/1.0が作成され、現在のブランチがそれに変更されます。ここで、デバッグおよびリリースに必要なバグ修正などの要修正点の適用を行っていきます。<br/>
また、この間に別のメンバーによって将来のリリースのための新しい機能を開発する場合は、以前の手順と同様の「新規フィーチャーを開始」から作成することが出来ます。<br/>
releaseブランチとフィーチャーブランチは完全に分けられ、互いに干渉することはありません。</p>

<p><img src="/images/2015-09-02-git-flow-release-graph.png" alt="git flow release graph" /></p>

<p>検証工程が完了し、リリースのタイミングになったら、ウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックします。現れたウィンドウで「現在のブランチを終了」をクリックします。下のようなダイアログが現れるので、「OK」をクリックしてください。</p>

<p><img src="/images/2015-09-02-git-flow-release-finish-dialog.png" alt="git flow release finish dialog" /></p>

<p>リリースブランチの終了では、いくつの操作が同時に行われます。</p>

<ul>
<li>release/1.0のmasterへのマージ</li>
<li>masterのHEADにタグ(1.0)の付加</li>
<li>release/1.0のdevelopへのマージ</li>
<li>release/1.0の削除</li>
</ul>


<p>結果として、以下のような状態になります。</p>

<p><img src="/images/2015-09-02-git-flow-release-finish-graph.png" alt="git flow release finish graph" /></p>

<p>タグ1.0(または現在のmasterの状態)が、バージョン1.0でリリースするべき状態になります。これをcloneなどをしてデプロイします。</p>

<h2>緊急修正</h2>

<p>バージョン1.0のリリースが完了し、次のバージョンアップに向けてdevelopブランチで開発を続けているところに、リリース済みの1.0に致命的でバグが発見され、緊急で修正の必要があるとします。<br/>
このようなときは、hotfixブランチを作成して対応することになります。</p>

<p>ウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックし、現れたウィンドウで「新規ホットフィックスを開始」をクリックします。<br/>
下のようなダイアログが現れるので、今回のホットフィックスでリリースするバージョンを入力して「OK」をクリックします。バージョンの付け方は各プロジェクトで個別に決まりがあると思いますが、ここではマイナーバージョンアップ&#8221;1.0.1&#8221;とします。</p>

<p><img src="/images/2015-09-02-git-flow-hotfix-start-dialog.png" alt="git flow hotfix start dialog" /></p>

<p>hotfix/1.0.1 というブランチが作成され、現在のブランチがこれに移ります。グラフは下のような状態になります。</p>

<p><img src="/images/2015-09-02-git-flow-hotfix-start-graph.png" alt="git flow hotfix start graph" /></p>

<p>ローカルの状態が前回リリース時の1.0の状態に戻るので、ここに緊急修正に必要なパッチだけを適用し、該当箇所の動作確認を至急おこなってリリースします。<br/>
リリースは、ウィンドウ上部のツールアイコンの&#8221;Git Flow&#8221;をクリックし、現れたウィンドウで「現在のブランチを終了」をクリックします。</p>

<p><img src="/images/2015-09-02-git-flow-hotfix-finish-dialog.png" alt="git flow hotfix finish dialog" /></p>

<p>「OK」をクリックすると、リリース時と同様にhotfixブランチがmasterとdevelopにマージされmasterのHEADにタグ&#8221;1.0.1&#8221;が付加されます。また、マージが終了したhotfixブランチは削除されます。</p>

<p><img src="/images/2015-09-02-git-flow-hotfix-finish-graph.png" alt="git flow hotfix finish graph" /></p>

<h1>まとめ</h1>

<p>以上が、git-flowを使って&#8221;A successful Git branching model&#8221;の運用を行う手順です。</p>

<p>git-flowを使って、機能開発、検証(テスト)工程、緊急修正を行う手順を説明しました。これらの修正は開発のフェーズとして全く異なる局面で適用されるものなので、プロダクトの信頼度を調整する上で正しく区別される必要があります。</p>

<p>また、git-flowが内部的にどのような処理を行っているかについても言及しました。大したことはやっていないので、&#8221;A successful Git branching model&#8221;を理解していればgit-flowの補助が無くても運用をするのは十分可能です。しかし、決まりきった処理を自力で複数のコマンドで行うというのも面倒なので、コマンドショートカットとしても有用であると考えられます。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/12/autoprefixer/">CSS3のクロスブラウザサポートを支援するAutoprefixer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-08-12T00:00:00+09:00" pubdate data-updated="true">Aug 12<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>AutoprefixerはCSS3のベンダ互換プレフィックスの管理をしてくれるツールです。<br/>
ベンダープレフィックスというのは、CSS3が勧告される前に各ブラウザが独自に該当機能を
実装していた時代に、記述の衝突を避けるためにプロパティ名に付加されて使用されていたプレフィックスです。</p>

<p>たとえば、border-imageは、昔はFirefoxでは</p>

<p>&#8220;`CSS</p>

<pre><code>-moz-border-image: url("bg_dot.png") 15 round;
</code></pre>

<p>&#8220;`</p>

<p>Chrome, Safariでは</p>

<p>&#8220;`CSS</p>

<pre><code>-webkit-border-image: url("bg_dot.png") 15 round;
</code></pre>

<p>&#8220;`</p>

<p>でした。結構昔の話なので、いつまでこうだったのかは覚えてないです。</p>

<p>ベンダプレフィックスは、各プロパティがCSS3勧告として正式採用されれば必要なくなるはずですが、<br/>
CSS3勧告は段階的に行われているので、今後もベンダープレフィックスが必要なプロパティが発生する
可能性はあります。(実際にはなさそうらしいですが…)<br/>
あと、ユーザーが古いバージョンのブラウザを使っている場合には未だにベンダープレフィックス付きの
CSSを作成する必要があります。</p>

<p>各ブラウザ、各バージョンでのCSSプロパティの対応状況(ベンダープレフィックスの必要有無も含む)は、
http://caniuse.com/ でまとめられているので、妖しげなプロパティを使う場合には確認するといいと思います。</p>

<h2>Autoprefixer</h2>

<p>さて、そんなベンダープレフィックスですが、各プロパティについてサポート対象とするブラウザが対応しているのかどうか、
を記憶しておくほど暇ではないですし、いちいち http://caniuse.com/ まで確認しにいくというのは面倒です。</p>

<p>ここで登場するのが、Autoprefixerです。</p>

<p>Autoprefixerは、CSSファイルを読み込み、記述内容をcaniuseの情報と照らしあわせて、必要あれば
ベンダープレフィックスを付けてCSSを出力してくれるという便利ツールです。<br/>
公式のgithubのREADMEによると、caniuseの最新の情報を参照して変換処理を行う、と書いてあります。<br/>
コマンドを実行するたびに最新情報を取得しに行くのか、ツールのアップデートのタイミングで情報更新を
行うのかは調べていません。</p>

<p>インストールには npm が必要です。</p>

<pre><code># npm install --global postcss-cli autoprefixer
</code></pre>

<p>そして、こんなCSSを書いてみます。</p>

<p>&#8220;`CSS</p>

<pre><code>a {
    display: flex;
}
</code></pre>

<p>&#8220;`</p>

<p>aptoprefixerで変換してみます。</p>

<pre><code>$ postcss --use autoprefixer main.css -o main.dist.css
</code></pre>

<p>すると、こんなCSSが吐き出されます。</p>

<p>&#8220;`CSS</p>

<pre><code>a {
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex;
}
</code></pre>

<p>&#8220;`</p>

<p>MozillaやWebkitのプレフィクスが自動で付加されました。</p>

<p>また、元のCSSに現在では不要なベンダープレフィックスが記述されている場合にそれを除去してくれる機能もあります。</p>

<p>&#8220;`CSS</p>

<pre><code>a {
    -webkit-border-radius: 5px;
        border-radius: 5px;
}
</code></pre>

<p>&#8220;`</p>

<p>という入力を与えると、実際には現在のWebkitエンジンではborder-radiusのベンダープレフィックスは不要なので、</p>

<p>&#8220;`CSS</p>

<pre><code>a {
    border-radius: 5px;
}
</code></pre>

<p>&#8220;`</p>

<p>となります。</p>

<p>実際には、複数のCSSを一括変換する必要があると思います。そのためには下記のようにします。</p>

<pre><code>$ postcss --use autoprefixer src/css/*.css -d dest/css
</code></pre>

<h3>サポートブラウザの指定</h3>

<p>上記の例では、デフォルトのサポートブラウザ指定を使いました。<br/>
実際にはプロジェクトごとにサポートするブラウザが決まっていると思います。<br/>
ブラウザバージョンの明示指定は以下のようにします。</p>

<pre><code>$ postcss --use autoprefixer \
--autoprefixer.browsers 'last 2 firefox versions, last 2 chrome versions, ie 10, ie 11' \
main.css -o main.dist.css
</code></pre>

<p>この指定では、Firefoxの最新の2バージョン、Chromeの最新の2バージョン、IE 10, 11をサポートするために
ベンダープレフィックスを付加するように指示しています。<br/>
上記の flex のプロパティが使われているCSSを入力すると、出力されるCSSは以下のようになります。</p>

<p>&#8220;`CSS</p>

<pre><code>a {
    display: -ms-flexbox;
    display: flex;
}
</code></pre>

<p>&#8220;`</p>

<p>caniuseの記述によると、上記指定のブラウザの中でベンダープレフィックスが必要なのは、IE10のみです。<br/>
http://caniuse.com/#feat=flexbox<br/>
ブラウザの指定が出力結果に反映されていることがわかります。</p>

<h3>サポートブラウザの自動指定</h3>

<p>と、ここまでだと、ふーんAutoprefixerやるじゃんすごいじゃん、という感じなのですが、さらにAutoprefixerには
サポートブラウザの自動選択の機能があるので、紹介しておきます。</p>

<p>autoprefixerコマンドに -i オプションを付加して実行すると、任意のブラウザ指定でどのブラウザがサポートされるのかと、
その指定の場合に必要とされるベンダープレフィックスの一覧が表示されます。</p>

<p>&#8220;&#8220;</p>

<pre><code>$ autoprefixer -i -b 'last 2 firefox version, last 2 chrome versions, ie 10, ie 11'
Autoprefixer CLI is deprecated. Use postcss-cli instead.
Browsers:
  Chrome: 44, 43
  Firefox: 39, 38
  IE: 11, 10

...
この下には、これらのブラウザで必要なベンダープレフィックスの一覧が表示されます
</code></pre>

<p>&#8220;&#8220;</p>

<p>最初の例では、明示的なブラウザ指定を行わずデフォルトの設定を使いました。<br/>
この時にサポートに入ったブラウザは何だったのでしょうか。 -b オプションなしで実行してみます。</p>

<p>&#8220;&#8220;</p>

<pre><code>$ autoprefixer -i
Autoprefixer CLI is deprecated. Use postcss-cli instead.
Browsers:
  Chrome for Android: 42
  UC for Android: 9.9
  Android: 4.4, 4.4.3-4.4.4, 4.2-4.3
  Chrome: 44, 43
  Firefox: 39, 38, 31
  IE: 11, 10, 9, 8
  IE Mobile: 11, 10
  iOS: 8.1-8.4, 8
  Opera Mini: 5.0-8.0
  Opera: 30, 29, 12.1
  Safari: 8, 7.1
</code></pre>

<p>&#8220;&#8220;</p>

<p>かなり多くのブラウザを対象としています。</p>

<p>ブラウザの明示指定がない場合、デフォルトでどのブラウザをサポートするのかは、
autoprefixerのサポートモジュールである browserlist のドキュメントに記載があります。</p>

<p>https://github.com/ai/browserslist</p>

<p>これによると、デフォルトのブラウザ指定は以下のようになっている、とあります。</p>

<pre><code>&gt; 1%, last 2 versions, Firefox ESR, Opera 12.1
</code></pre>

<p>カンマ区切りで複数の条件が指定されています。</p>

<p>|> 1%|主要ブラウザのうち、ユーザーシェアが1%以上のブラウザとそのバージョンを指定します|
|last 2 versions|主要ブラウザのうち、最新の2バージョンを指定します|
|Firefox ESR|Firefoxの法人向けサポート版です|
|Opera 12.1|Opera Presto版の最新バージョンです|</p>

<p>「主要ブラウザ」というのは、 Chrome, Firefox, IE, IE Mobile, iOS Safari, Opera, Safari を指します。<br/>
面白いのは、最初のシェア割合の指定で、古いブラウザでも何らかの事情で利用が停止されていないものは
自動的にサポート対象に含められることになります。<br/>
Androidの旧ブラウザなんかは、ベンダの改造OSがアップデート出来ない影響で使い続けている人が
少数だがまだいる、ということのようです。<br/>
IE8はシェア2%指定にすると消えますが、まだ少し使ってる人がいるということのようですね。XPでしょうか。</p>

<p>国別シェアの指定を行うことも出来ます。アメリカで2％以上のシェアがあるブラウザを指定するには、以下のようにします。</p>

<pre><code>$ autoprefixer -i -b "&gt; 2% in US"
Autoprefixer CLI is deprecated. Use postcss-cli instead.
Browsers:
  Chrome for Android: 0
  Chrome: 44, 43
  Firefox: 39, 38
  IE: 11
  iOS: 8.1-8.4
  Safari: 8
</code></pre>

<p>対して、日本で2％以上のシェアがあるブラウザを指定するには、以下のようにします。</p>

<pre><code>$ autoprefixer -i -b "&gt; 2% in JP"
Autoprefixer CLI is deprecated. Use postcss-cli instead.
Browsers:
  Chrome for Android: 0
  Android: 4.4
  Chrome: 44, 43
  Firefox: 39
  IE: 11, 9
  iOS: 8.1-8.4
</code></pre>

<p>日本だとアメリカに比べてIE9のシェアが多いです。Vistaでしょうか。7をアップデートしないまま使ってるユーザーでしょうか。<br/>
あと、Android4.4ブラウザは日本のベンダーカスタマイズAndroidのせいだと思います。<br/>
まあブラウザシェア自体は調べればすぐにわかるのですが、CSSの調整に直接適用してしまおうというのが面白いと思います。</p>

<p>というわけで、autoprefixerを使うことで、将来的なブラウザのアップデートや、シェアの変化に対応した
最適なCSSを自動的に作成できる、ということになります。</p>

<h3>Gruntからの利用</h3>

<p>Autoprefixerの処理をGruntのビルド処理に含めることが出来ます。<br/>
ここまでの例では色々試したかったのでコマンドラインで使いましたが、ビルドプロセスに含めて自動で処理するほうが
一般的だと思います。</p>

<p>Gruntfile.js に以下を記述</p>

<p>&#8220;`Javascript</p>

<pre><code>autoprefixer: {
    options: {
        browsers: ['last 2 version', 'ie 8', 'ie 9']
    },
    file: {
        expand: true,
        flatten: true,
        src: 'src/css/*.css',
        dest: 'dest/css/'
    },
}
</code></pre>

<p>&#8220;`</p>

<p>ぐぐるといっぱい出てくると思うので、詳細は割愛します。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/20/grunt-php/">ビルドツールGrunt.jsをPHP開発で利用する</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-20T00:00:00+09:00" pubdate data-updated="true">Jul 20<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>通常、Webアプリケーション開発で使われる軽量プログラミング言語ではコンパイルが不要であるため、
Javaのmaven, Cのmakeに相当するようなビルドツールはこれまで利用されてきませんでした。<br/>
しかし、近年のWebアプリケーション開発ではデプロイ時に開発リソースに対して以下のような前処理が
行われることが増えてきたため、これらの作業の自動化、共有化の目的でビルドツールが利用されるように
なってきています。</p>

<ul>
<li>外部ライブラリの依存関係解決とアプリケーションへの組み込み</li>
<li>Javascript, CSSのminify</li>
<li>Sass, CompassなどのCSS出力スクリプトのコンパイル</li>
<li>リソースURLの難読化</li>
</ul>


<p>加えて、継続的インテグレーション(CI)のための次のような機能も提供されます。</p>

<ul>
<li>デバッグサーバーの起動</li>
<li>ファイル保存時の構文チェックやコード規約チェック自動化</li>
<li>ファイル保存時のテスト自動化</li>
</ul>


<p>このエントリでは、Webフロントエンド開発(Javascript開発)で広く利用されているビルドツールである
GruntをPHPのバックエンド開発まで含めて利用する例を記載します。</p>

<h1>YeomanによるPHPアプリケーションプロジェクトサンプルの作成</h1>

<p>Yeomanは、Gruntプロジェクトのテンプレートを作成するツールです。<br/>
作業を始める前に、まずはYeomanとGruntのインストールを行います。npmが利用できる環境で、</p>

<pre><code># npm install -g yo grunt-cli bower
</code></pre>

<p>としてください。</p>

<p>また、phpプロジェクトテンプレートのインストールを行います。これは一般に公開されているものがあるのですが、
メンテナンスが停止していて微妙な感じだったので、社内リポジトリに修正拡張したものを配置しました。
こちらをインストールしてみてください。</p>

<pre><code># npm install -g http://192.168.142.11:8080/ikeda_shoichi/generator-php
</code></pre>

<p>上記ツール類がインストールできたら、プロジェクトを作成します。</p>

<pre><code>$ mkdir php-sample
$ cd php-sample
$ yo php

     _-----_
    |       |
    |--(o)--|   .--------------------------.
   `---------´  |    Welcome to Yeoman,    |
    ( _´U`_ )   |   ladies and gentlemen!  |
    /___A___\   '__________________________'
     |  ~  |
   __'.___.'__
 ´   `  |° ´ Y `

I'll be scaffolding out a php website for you.
Out of the box you're going to get:
- HTML5 Boilerplate
- jQuery (v1.11)
- Modernizr (v2.8.3)
[?] What's the production URL for this site? hoge.example.com
[?] and the dev URL? 127.0.0.1
[?] What port should I use for the dev URL? 50080
[?] Use PHP's built-in web server for dev testing? Yes
[?] Which CSS preprocessor shall I use (none, sass, compass)? compass
[?] Which version of Twitter Bootstrap shall I include (none, 2.3.2, 3.3.5, etc)? 3.3.5
[?] Include Foundation Framework (v3)? No
[?] Which files should be versioned to force cache expiration (none, all, css, js, img)? all
[?] What name should I give the application directory where your development files are placed? app
[?] What name should I give the distribution directory where compiled output files are placed? dist
</code></pre>

<p>yoコマンドを実行すると、怪しげな紳士のAAの表示とともに、プロジェクト作成に必要ないくつかの質問をされます。</p>

<p>What&#8217;s the production URL for this site?
: 作成されるWebサイトのURLです。</p>

<p>and the dev URL?
: デバッグサーバー立ち上げの際のURLを聞かれます。<br/>
ローカルホストで立ち上げる場合はループバックアドレスを入力すればよいですが、開発サーバーなどで立ち上げる場合は
そのプライベートアドレスとかにするべきです。</p>

<p>What port should I use for the dev URL?
: デバッグサーバーのポートを指定します。他のプログラムで使用されていないポートを指定する必要があります。</p>

<p>Use PHP&#8217;s built-in web server for dev testing?
: デバッグサーバーにPHPビルドインサーバーを利用するかどうかを指定します。デフォルトでは利用しないということになっていますが、
Yesを選択します。</p>

<p>Which CSS preprocessor shall I use (none, sass, compass)?
: CSS preprocessor scriptを選択します。sassはyeomanテンプレートのバグでなんだか使えないので、compassを選択します。
ちなみにCSS preprocessor を使っていても、通常のCSSと同じように記述していればそのままCSSとして出力されます。</p>

<p>Which version of Twitter Bootstrap shall I include (none, 2.3.2, 3.3.5, etc)?
: Twitter Bootstrapを利用するかどうかと、バージョンを指定します。プロジェクトごとに任意に選択してください。</p>

<p>Include Foundation Framework (v3)?
: Foudation Frameworkを利用するかどうかを指定します。私も使ったことがないのでNoを指定しています。</p>

<p>Which files should be versioned to force cache expiration (none, all, css, js, img)?
: ブラウザのキャッシュ機能で古いリソースがユーザーに利用され続けたりすることを防いだり、URLの法則性から
画像リソースを予測してアクセスされるのを防ぐために、リソースURLの難読化を行うかどうかを指定します。
allを選択します。</p>

<p>What name should I give the application directory where your development files are placed?
: アプリケーションプログラムの配置ディレクトリを指定します。特に問題がなければデフォルトのappを指定します。</p>

<p>What name should I give the distribution directory where compiled output files are placed?
: ビルド済みプログラムの配置ディレクトリを指定します。特に問題がなければデフォルトのdistを指定します。</p>

<p>これらを入力すると、npmで必要な依存ライブラリなどのダウンロードがはじまり、
しばらく待っているとプロジェクトテンプレートが作成されます。</p>

<h1>Gruntプロジェクトの利用方法</h1>

<h2>ビルド</h2>

<pre><code>$ grunt
</code></pre>

<p>とりあえず、おもむろにgruntコマンドを実行すればビルドが開始されます。<br/>
しかし、ビルドの過程で行われるJavascriptのユニットテストがひとつもテストが無い状態だと失敗扱いになるので、
とりあえずビルドを完遂するために、ここは</p>

<pre><code>$ grunt --force
</code></pre>

<p>としてください。あるいは、テストプロセスをスキップしてビルドだけを行うには</p>

<pre><code>$ grunt build
</code></pre>

<p>とします。<br/>
テストの作成、配置の方法は後述します。</p>

<p>このプロジェクトにおいてビルドの過程で行う処理は、以下のものになります。</p>

<ul>
<li>Javascript Syntax check</li>
<li>PHP Syntax check</li>
<li>PHP ライブラリ依存関係の解決(composer)</li>
<li>Javascript ユニットテスト実行</li>
<li>PHP ユニットテスト実行</li>
<li>compassのコンパイル</li>
<li>html圧縮</li>
<li>CSS3ベンダー互換記述の整理(autoprefix)</li>
<li>CSS圧縮</li>
<li>Javasctript圧縮</li>
<li>リソースURLの難読化、参照箇所のURL置換</li>
</ul>


<h2>デバッグサーバーの立ち上げ</h2>

<pre><code>$ grunt server
</code></pre>

<p>上記コマンドで、php ビルドインサーバーが起動しデバッグサーバーが立ち上がります。<br/>
デバッグサーバーのポートはプロジェクト作成時に指定したものが使われるので、
サーバー立ち上げ前にこのポートが未使用であることを確認してください。</p>

<p>デバッグサーバーは、ローカルのファイルを監視し、変更があった時自動でページの
再読み込みを行ったり、compassのコンパイル、javascriptのシンタックスチェック、
ユニットテストの実行などを行います。</p>

<h2>ユニットテスト</h2>

<p>ユニットテストを実行するには、以下のコマンドを実行します。</p>

<pre><code>$ grunt test:continuous
</code></pre>

<p>テストはJavascriptとPHPについて配置されているテストをすべて実行します。</p>

<h3>Javascript</h3>

<p>Javascriptのテストフレームワークにはkarmaを使っています。<br/>
test/js/spec/ 以下にテストファイルを配置してください。</p>

<p>&#8220;`javascript</p>

<pre><code>'use strict';

describe('test for someMethod', function() {
    it('someMethod returns true', function() {
        expect(someMethod()).toBe(true);
    });
});
</code></pre>

<p>&#8220;`</p>

<h3>PHP</h3>

<p>PHPのテストフレームワークはphpunitを使っています。<br/>
test/php/classes/ 以下にテストファイルを配置してください。</p>

<p>&#8220;`PHP</p>

<pre><code>&lt;?php
class StackTest extends PHPUnit_Framework_TestCase
{
    public function testPushAndPop()
    {
        $stack = array();
        $this-&gt;assertEquals(0, count($stack));

        array_push($stack, 'foo');
        $this-&gt;assertEquals('foo', $stack[count($stack)-1]);
        $this-&gt;assertEquals(1, count($stack));

        $this-&gt;assertEquals('foo', array_pop($stack));
        $this-&gt;assertEquals(0, count($stack));
    }
}
</code></pre>

<p>&#8220;`</p>

<h1>まとめ</h1>

<p>Webのフロントエンド開発でよく用いられるビルドツールであるGruntを使って、
バックエンド側のPHPプログラムのビルドや開発ツールも利用する手順を紹介しました。<br/>
これにより、フロントエンド側とバックエンド側のビルド処理を統一的に扱うことが
可能になり、ビルド処理の見通しをわかりやすく管理することができます。</p>

<p>Gruntをはじめとするビルドツールの多くは、プラグイン方式を採用しており、
ビルド処理を管理するビルドツールと個々のビルド処理は独立した開発が行われています。</p>

<p>開発者は自分が必要だと思う処理を選択または自分で作成して、ビルドに含めることができます。<br/>
すべてのビルド処理を自分で選択するというのはなかなか大変なので、Yeomanという
プロジェクトテンプレートツールを併用することで、一般的に必要と思われるビルド処理を簡単に
構築することが出来ます。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/07/phonegap/">Cordovaからハードウェア機能を利用する</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-07T00:00:00+09:00" pubdate data-updated="true">Jul 7<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリは、Developer summit 2015 のセッション
&#8220;エンタープライズ要件に対応する高品質なCordovaアプリ開発のポイント&#8221;の
レポートです。</p>

<h2>Cordova</h2>

<p>Cordovaとは、AndroidやiOSなどのスマートデバイス用のアプリケーションの
クロスプラットフォーム開発を行うためのフレームワークです。開発はHTML5+Javascriptで行います。</p>

<p>CordovaはもともとPhonegapという名称でニトビ・ソフトウェアによって開発されていましたが、
現在はAdobeに買収され、そのプロダクトになっています。しかし、ソースコードはApacheに寄贈され、
Cordovaという名称でオープンソース開発が進められています。</p>

<p>というわけで、最新のパッケージを利用したり情報を追いかけるにはCordovaの名称で検索したほうがよいです。</p>

<h3>Cordova開発のメリット/デメリット</h3>

<p>HTML5+Javascriptによるクロスプラットフォーム開発ということで、以下のようなメリットが得られます。</p>

<ul>
<li>複数プラットフォーム間でのソースコード共有</li>
<li>OSバージョン間のAPI差異をフレームワークで吸収してくれる</li>
<li>標準的なWeb技術で開発が可能で各プラットフォームに対する学習コストの軽減</li>
</ul>


<p>他のフレームワークの基盤技術としても用いられており、実質的にスマートデバイスのHTML5開発ではデファクトスタンダードという扱いになっています。
Cordovaを基盤としたフレームワークはSenchaやOnsenUI、monakaなどがあります。</p>

<p>しかし、反面やはりデメリットも存在し、とくにネイティブアプリとのデザインの差異については理解しておく必要があります。CSSによるスタイル再現ということになるので、どう頑張ってもネイティブ描画とのイメージの違いがあります。デザインの良し悪しはCSSによるスタイル次第ということになりますが、iOSユーザーなどはスタイリッシュなネイティブアプリの見た目に慣れているため、たとえばApple Storeでの評価上位を目指すというような目的で作成するアプリケーションには向かない可能性があります。</p>

<h3>Cordova開発における注意点</h3>

<p>開発手法としてはWebアプリケーションのものを使うということになるので、Webアプリケーションで一般的に行われるセキュリティ対策は行わなければなりません。ネイティブアプリケーション開発では通常行わないものなので、落とし穴になりがちです。</p>

<p>まず、クロスサイトスクリプティングへの対応が必要になります。ユーザー入力を使用する可能性のある文字列(というか通信で取得されたデータ全般について行うよう統一したほうがよいでしょう)は適切にエスケープしてHTMLに埋め込む必要があります。これについては、AngularJSやjQueryなどのクライアントサイドフレームワークを用いることで負担を回避することができます。</p>

<p>また、ネイティブコードではコードの暗号化が通常行われますが、アセット内のJavascriptについてはなされないので独自に難読化などの対応を行う必要があります。ただ、難読化といっても効果に限界があるので、ミッションクリティカルなコードやデータについてはアプリケーションパッケージに含めないという対処が必要になります。</p>

<p>あと、クロスプラットフォーム開発環境ということで、ハードウェア機能の利用についてはひと手間かかるため、そのような機能が必要になる場合は一考したほうがよいという話がありました。しかし、これについてはエントリ後半で追加調査と検討を行ったので参照してください。</p>

<h2>Cordovaからハードウェア機能を利用する</h2>

<p>ということで、ここからは追加検証です。
セッションではCordovaからのハードウェア機能の利用は無理に行わないほうがよいという話がありましたが、現在のCordovaではハードウェア機能についてはプラグインの形でモジュールがまとめられており、わりあい簡単に導入することが出来ます。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/06/angular-jqui/">AngularJSから他ライブラリの利用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-06-06T00:00:00+09:00" pubdate data-updated="true">Jun 6<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリは、Developer summit 2015 のセッション
&#8220;AngularJSの今とこれから - フロントエンドエンジニア座談会（仮）&#8221;の
レポートです。</p>

<h2>AngularJSサンプルアプリケーションの構築</h2>

<p>AngularJSプロジェクトの初期構築にはyeomanの利用が便利です。
まず、npmがインストールされているという前提で、yeoman および
AngularJSプロジェクトテンプレートのインストールを行います。</p>

<pre><code>$ npm install -g yo generator-angular grunt-cli bower
</code></pre>

<p>つぎに、yeomanでテンプレートからAngularJSプロジェクトを作成します。</p>

<pre><code>$ mkdir sampleApp; cd sampleApp
$ yo angular
</code></pre>

<p>作成されたプロジェクトでは、すでにいい感じのGruntfileが用意されており、
デバッグサーバーの立ち上げが可能です。</p>

<pre><code>$ grunt serve
</code></pre>

<p>これで localhost:9001 にアクセスすればプロジェクトのプレビューが閲覧できます。</p>

<h2>AngularJSとReactive</h2>

<p>従来のフロントエンドフレームワークと比べたAngularJSの特徴は、Reactiveのしくみです。
たとえば、「ユーザーがテキストフィールドに入力した文字列を画面に反映する」という
機能をjQueryで実装しようとした場合、以下のようになるかと思います。</p>

<p>HTML</p>

<pre><code>&lt;div&gt;
    &lt;input id="input"&gt;
    &lt;p id="result"&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>Javascript</p>

<pre><code>$('#input').change(function() {
  $('#result').text($(this).val());
});
</code></pre>

<p>これに対し、AngularJSではつぎのように実装することができます。</p>

<pre><code>&lt;div ng-init="a = 'hoge'"&gt;
    &lt;input id="input" ng-model="a"&gt;
    &lt;p id="result"&gt;{{a}}&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>このように、Reactiveのしくみを使うことで、このような処理で従来必要であった
Javascriptを記述する必要が無くなります。
この機能でやらなければならない処理は、「入力フィールドの変更を検知し」
「入力内容を画面に反映する」ということですが、これをフレームワークの機能として
提供し、ユーザーは変数である「入力値」の定義を行うだけで実現できるように
したのが、Reactiveです。
この入力値や変数の画面への反映という処理を従来通りに記述すると、
フロントエンド側のプログラムのかなりの部分を占めることになります。
これをフレームワークに負わせることにより、アプリケーションコードの縮小、
メンテナンスコストの低減が期待できます。</p>

<h2>AngularJSから別のライブラリの利用</h2>

<p>で、ここからが本題ですが、デブサミのセッションで「jQuery UIなどの外部ライブラリを
AngularJS、とりわけReactiveのしくみのなかで扱おうとするのは鬼門である」という
コメントがありました。</p>

<p>なので、本当に鬼門なのか実際にやってみます。</p>

<p>ここでは、jQuery UIのDatepickerをAngularJSっぽく使えるようにするDirectiveを
新規実装してみます。AngularJSっぽく使えるDirectiveとは、Template HTML中で
つぎのように使えるよう実装することです。</p>

<pre><code>&lt;div calendar value="date"&gt;&lt;/div&gt;
&lt;p&gt;{{date}}&lt;/p&gt;
</code></pre>

<p>&#8220;calendar&#8221;属性がついたdiv要素がjQuery UIのDatepickerに置換して表示され、
その中で変更された日付変数が下のp要素中に自動で表示されるようにします。</p>

<p>calendar属性のついた要素がDatepickerに置換されるようにするには、つぎのように
Directiveを実装します。</p>

<pre><code>'use strict';

angular.module('jquiSampleApp')
.directive('calendar', function() {
  return {
    link: function($scope, $element) {
      $element.find('input').datepicker();
    },
    template: '&lt;p&gt;Date: &lt;input type="text"&gt;&lt;/p&gt;',
    scope: {
      value: '='
    }
  };
});
</code></pre>

<p>しかし、これではjQuery UIで変更された値をView側の変数に反映するコードが
無いので、それを追加する必要があります。
これには入力に変更があったときに $scope.value を変更すればよいのですが、</p>

<pre><code>$element.find('input')
.change(function() {
    var s = $(this).val().split('/');
    var m = parseInt(s[0] - 1);
    var d = parseInt(s[1]);
    var y = parseInt(s[2]);
    $scope.value = new Date(y, m, d);
});
</code></pre>

<p>と普通にやっても画面上に変更が反映されません。
(正確には反映されないわけではなく、別のAngularJS上のイベントが発生したときに
反映されます。)</p>

<p>View変数の変更を画面に反映する処理は、&#8221;digest loop&#8221;という処理の中で発生します。
digest loopは、画面上のUIイベントが発生したタイミングで開始され、AngularJSが
定義しているイベントハンドラ(ng-clickとか)の呼び出しを行い、その後View変数の
変更をチェックして必要があれば画面への反映を行います。
このため、通常通りclick属性などで定義したイベントハンドラはdigest loop
の外で処理されることになるので、その中で行われたView変数の変更は画面表示には
すぐに反映されず、つぎのdigest loopの実行時まで待たなければならない、ということになります。
これは、jQuery UIに限らず独自のイベントハンドラをセットして使っているライブラリを
AngularJS中で扱おうとしたときに常に注意が必要ということになります。</p>

<p>digest loopを任意に呼び出して画面への反映を行うには、以下のようにします。</p>

<pre><code>$element.find('input')
.change(function() {
    $scope.$apply(function() {
        var s = $(this).val().split('/');
        var m = parseInt(s[0] - 1);
        var d = parseInt(s[1]);
        var y = parseInt(s[2]);
        $scope.value = new Date(y, m, d);
    });
});
</code></pre>

<p>$scope.$apply() はその場でdigest loopを呼び出し、その中の処理として引数で与えられた関数を
実行します。</p>

<p>注意しなければならないのは、この$scope.$apply()関数をdigest loop中で呼び出すとエラーが発生
するという点です。確実にdigest loopの外で呼ばれるよう、イベントハンドラの中で直接呼ぶように
したほうが無難です。</p>

<p>さて、これで入力フィールドの変更内容が画面に反映され、完成と言いたいところですが、まだ一点
問題が残っています。入力フィールド以外から変数が変更された際に入力フィールドに値が反映されない
という点です。</p>

<p>外部ライブラリを扱う際は、変数の変更を自分で検知して入力フィールドに反映させる処理を
書く必要があります。</p>

<pre><code>  $scope.$watch('value', function(value) {
    var dateStr = (value.getMonth() + 1)
          + '/' + value.getDate()
          + '/' + value.getFullYear();
    $element.find('input').val(dateStr);
  }, true);
</code></pre>

<p>$scope.$watch()はView変数を監視し、変更があった際に指定したコールバックを実行するよう設定する
関数です。
第3引数は、監視対象の変数オブジェクトのメンバーの変更を再帰的に監視するかどうかのフラグです。
これをfalseまたは未指定にすると、setDate()メソッドなどによりDate型変数の内容が変更されただけでは
コールバックが呼び出されず、再代入が行われた時にだけ実行される、ということになります。
しかし巨大なオブジェクトを再帰的に監視するという場合は処理コストがかなりかかることが懸念されるので、
できればプリミティブ型の変数をnon-recursiveで監視したほうが無難かと思います。</p>

<p>以上が外部ライブラリをAngularJSで扱う場合の流れになります。実装は不可能ではありませんが、
結構めんどくさく、しかも途中で $scope.$watch を使わざるをえないというところでパフォーマンス的な
懸念もあります。</p>

<p>DatepickerならばjQueryを使わずともangular-bootstrapなどですでにAngularJSベースで開発された
コンポーネントが存在するので、そちらを使ったほうが無難です。
jQueryUIコンポーネントのwrapをしたものも出回っていますが、先に述べたようにパフォーマンスの懸念が
あるのと、入出力双方まで対応していないなど微妙な実装のものもあるので、できればあまり使わない
ほうがいい、という印象です。</p>

<p>しかし、マイナーなライブラリをAngularJS上で扱いたい場合は独自にwrapperを作成しなければ
ならない、ということもあります。その際には上記のようなところを注意すると良いと思います。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/27/bousaixml/">気象庁防災情報XMLフォーマットの利活用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-27T00:00:00+09:00" pubdate data-updated="true">May 27<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>気象庁防災情報XMLフォーマットは、気象庁から配信する防災関連情報のあたらしい仕組みです(現在トライアル版で稼働中)。</p>

<p>配信形式としてPubSubHubbubというプロトコルを用いることで即時性の高い情報配信を行えるようになっています。
また、配信形式はXMLフォーマットで仕様も公開されているので、別のシステムなどで配信情報を利用するマッシュアップも
行いやすいように設計されています。</p>

<h2>PubhubSubbub</h2>

<p>PubSubHubbubは、Atom, RSSなど記事配信プロトコルの代替仕様として開発されたしくみです。従来用いられていたAtom, RSS
ではクライアントサイドから定期的に新規情報が無いかを問い合わせるPop形式の情報取得を行うのに対し、PubSubHubbubでは
サーバーサイドからクライアントサイドへのPush形式で記事更新情報の通知が行われます。
これによって、クライアントサイドとしては即時性の高い更新情報が得られるというメリットがあり、またサーバーサイドでも
従来行われていたクライアントからのポーリングアクセスがなくなるので、負荷軽減や通信トラフィック減少というメリットが
あります。</p>

<p>基本的なしくみとしては下図のようになります。</p>

<p><img src="images/2015-05-27-pubsubhubbub.png" alt="pubsubhubbub" /></p>

<p>記事配信者(Publisher)は更新情報がある場合、あらかじめ配信者側で用意しておいたHubサーバーに通知を行います。
HubサーバーはPublisherからの通知を受け取ると、これもあらかじめ購読者として登録されているSubscriberサーバーへ
Push通知を行います。この通知の方法はHTTPアクセスで、リクエスト仕様もプロトコルの一部として決められています。
このときSubscriberに渡される通知はAtomファイルのみなので、その情報がSubscriberにとって欲しいものであれば、
Publisherのサーバーにアクセスし詳細な情報を取得するという流れになります。</p>

<p>気象庁による防災関連情報は即時性を高めることでユーザーに対し有益となる類のものが多いため、PubSubHubbub
プロトコルが採用されています。配信形式の詳しい情報は添付ファイルを参照してください。</p>

<h2>利用の仕組みと利用例</h2>

<p>PubSubHubbubの仕組みをつかって気象庁から情報を取得するしくみはすでに作成済みなので、今後実際に利用する場合は
取得された情報を受け取りアプリケーションから実際に利用する部分のスクリプトだけを作成すればよいです。
(という予定ですが、じつはまだ任意のアプリケーション処理を拡張するしくみは整っていません。実際に利用する
プロジェクトがあればそれなりに急いで作成します)</p>

<p>配信される情報の種類は添付ファイルを参照してください。</p>

<p>ここでは、利用例として「震源・震度に関する情報」から震度マップを作成し、地図と重ねあわせて配信する流れを
紹介します。</p>

<p><img src="images/2015-05-27-shindomap.png" alt="shindomap" /></p>

<p>「震源・震度に関する情報」は地震発生時に震源、各地震度に関する最終情報として通知される情報です。
震源震央地名と最終的なマグニチュードと、市区町村レベルまでの各地震度情報が含まれています。</p>

<p><strong><em>地震情報部分</em></strong></p>

<pre><code>&lt;Earthquake&gt;
&lt;OriginTime&gt;2015-05-25T14:28:00+09:00&lt;/OriginTime&gt;
&lt;ArrivalTime&gt;2015-05-25T14:28:00+09:00&lt;/ArrivalTime&gt;
&lt;Hypocenter&gt;
&lt;Area&gt;
&lt;Name&gt;埼玉県北部&lt;/Name&gt;
&lt;Code type="震央地名"&gt;330&lt;/Code&gt;
&lt;jmx_eb:Coordinate description="北緯３６．１度　東経１３９．６度　深さ　５０ｋｍ" datum="日本測地系"&gt;+36.1+139.6-50000/&lt;/jmx_eb:Coordinate&gt;
&lt;/Area&gt;
&lt;/Hypocenter&gt;
&lt;jmx_eb:Magnitude type="Mj" description="Ｍ５．６"&gt;5.6&lt;/jmx_eb:Magnitude&gt;
&lt;/Earthquake&gt;
</code></pre>

<p><strong><em>各地震度情報部分</em></strong></p>

<pre><code>&lt;Intensity&gt;
&lt;Observation&gt;
&lt;CodeDefine&gt;
&lt;Type xpath="Pref/Code"&gt;地震情報／都道府県等&lt;/Type&gt;
&lt;Type xpath="Pref/Area/Code"&gt;地震情報／細分区域&lt;/Type&gt;
&lt;Type xpath="Pref/Area/City/Code"&gt;気象・地震・火山情報／市町村等&lt;/Type&gt;
&lt;Type xpath="Pref/Area/City/IntensityStation/Code"&gt;震度観測点&lt;/Type&gt;
&lt;/CodeDefine&gt;
&lt;MaxInt&gt;5-&lt;/MaxInt&gt;
&lt;Pref&gt;&lt;Name&gt;茨城県&lt;/Name&gt;&lt;Code&gt;08&lt;/Code&gt;&lt;MaxInt&gt;5-&lt;/MaxInt&gt;
&lt;Area&gt;&lt;Name&gt;茨城県南部&lt;/Name&gt;&lt;Code&gt;301&lt;/Code&gt;&lt;MaxInt&gt;5-&lt;/MaxInt&gt;
&lt;City&gt;&lt;Name&gt;土浦市&lt;/Name&gt;&lt;Code&gt;0820300&lt;/Code&gt;&lt;MaxInt&gt;5-&lt;/MaxInt&gt;
&lt;IntensityStation&gt;&lt;Name&gt;土浦市常名&lt;/Name&gt;&lt;Code&gt;0820301&lt;/Code&gt;&lt;Int&gt;5-&lt;/Int&gt;&lt;/IntensityStation&gt;
&lt;IntensityStation&gt;&lt;Name&gt;土浦市下高津＊&lt;/Name&gt;&lt;Code&gt;0820330&lt;/Code&gt;&lt;Int&gt;4&lt;/Int&gt;&lt;/IntensityStation&gt;
&lt;/City&gt;
...
</code></pre>

<p>情報更新のPush通知をPHPスクリプトで受け取り、このとき通知された情報が「震源・深度に関する情報」であった場合は
詳細情報のXMLを取得して解析し、データベースに保存します。</p>

<p><img src="images/2015-05-27-erdiagram.png" alt="erdiagram" /></p>

<p>このデータに含まれる各地震度情報には、市区町村名の他に別の行政データでも使われている行政区域コードも&lt;Code&gt;要素として
含まれています。</p>

<ul>
<li>Pref(県) → 県コード(2桁)</li>
<li>Area(地域) → 地域コード(3桁)</li>
<li>City(市町村) → 市町村コード(7桁だが下2桁は必ず0で実質5桁)</li>
</ul>


<p>この「行政区域コード」は、その他の行政機関から公開されているデータで使っているコードと共通のものとなってい(ることが期待され)ます。
国土地理院から提供されている行政区域ポリゴンに含まれるコードとは一致していることが確認されたので、
これらふたつのデータを組み合わせて震度マップを作成します。
(気象庁XMLの市町村コードの上5桁と国土地理院データのコードが一致、これは一致することを保証する仕様であることを
担当機関に確認したわけではなく、現在の全データを照合して不一致となるデータが存在しないことを確認しました)</p>

<h2>震度マップ作成手順</h2>

<p>国土数値情報から、「行政区域」データを取得します。</p>

<p><a href="http://nlftp.mlit.go.jp/ksj/">http://nlftp.mlit.go.jp/ksj/</a></p>

<p><img src="images/2015-05-27-gyoseikuiki.png" alt="gyoseikuiki" /></p>

<p>形式はGMLとSHAPEが選択できますが、データベースなどで扱いやすいSHAPEを選択しましょう。</p>

<p>shp形式からPostGISデータへの変換</p>

<pre><code>$ shp2pgsql -s 4612 -W "Shift_JIS" N03-14_140401.shp &gt; N03-14_140401.dump 
</code></pre>

<p>このデータを、気象庁XMLデータを保存しているデータベースに流し込みます。
PostGISのインストールがされていなければ、行政区域データを流しこむ前にやっておきます。</p>

<pre><code>$ psql -U postgres jmajihin &lt; N03-14_140401.dump
</code></pre>

<p>この行政区域ポリゴンデータは、離島や飛び地などのポリゴンがすべて独立したレコードとして登録されているので、
このままで市町村ごとの震度データを扱っている気象庁データと結合すると、動作が非常に重くなります。
(市町村数1900に対し、地形ポリゴンは73万レコードを超えます。日本が島国であることを実感させられます)
あらかじめ、同じ市町村のデータはMultipolygonの同じレコードとして登録しなおしておきましょう。</p>

<pre><code>CREATE TABLE gyoseikuiki (
    gid INTEGER primary key, 
    n03_001 VARCHAR(16), 
    n03_002 VARCHAR(16), 
    n03_003 VARCHAR(16), 
    n03_004 VARCHAR(16), 
    n03_007 VARCHAR(16)
);
SELECT addgeometrycolumn('gyoseikuiki', 'the_geom', 4612, 'MULTIPOLYGON', 2);

INSERT INTO gyoseikuiki (
    gid INTEGER PRIMARY KEY,
    n03_001 VARCHAR(16),
    n03_002 VARCHAR(16),
    n03_003 VARCHAR(16),
    n03_004 VARCHAR(16),
    n03_007 VARCHAR(16))
    SELECT
        min(gid) AS gid,
        min(n03_001) AS n03_001,
        min(n03_002) AS n03_002,
        min(n03_003) AS n03_003,
        min(n03_004) AS n03_004,
        n03_007,
        ST_Union(geom) AS geom
        FROM "n03-14_140401"
    GROUP BY n03_007;
</code></pre>

<p>最後に、気象庁震度データと行政区域ポリゴンデータを結合したViewを作成します。</p>

<pre><code>CREATE VIEW eq20150408085132 AS
SELECT g.gid,
    c.code,
    c.max_int,
    g.the_geom
FROM cities c
    JOIN areas a ON a.id = c.areas_id
    JOIN prefectures p ON p.id = a.prefectures_id
    JOIN events e ON e.id = p.earth_quakes_id
    JOIN gyoseikuiki g ON (g.n03_007 || '00'::text) = c.code::text
WHERE e.event_id::text = '20150408085132'::text;
</code></pre>

<p>このViewを、Geoserverなどの地理データ配信サーバーからWMS形式で配信すれば、OpenlayersやGoogleMapなどの
マップAPI上で扱えるようになります。</p>

<p><a href="http://54.248.218.93/jmajishin/">http://54.248.218.93/jmajishin/</a></p>

<h2>まとめ</h2>

<p>気象庁防災情報XMLフォーマットから情報を取得し、ユーザーが利用できる形に加工して提供するサービスのサンプルを作成した。</p>

<p>気象庁防災情報XMLフォーマットのよいところ</p>

<ul>
<li>仕様が公開されたXMLフォーマットによる配信。ユーザーアプリケーションによるマッシュアップが容易である</li>
<li>即時性の高いPush通知による配信。とくにスマートデバイスなどへの情報通知に強みを発揮するだろう</li>
<li>他の行政データとの連携も可能な設計となっており、組み合わせて利用することが可能である</li>
</ul>


<p>ただし、現在トライアル版というところがネックで、今後仕様の変更や有料化といった大きな変化がおこる可能性は否めません。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/05/hoge/">ほげほげ</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-05T00:00:00+09:00" pubdate data-updated="true">Dec 5<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ほげ</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/09/04/git-branch/">Git Branch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/02/git-flow/">gitのブランチ運用とgit flow</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/12/autoprefixer/">CSS3のクロスブラウザサポートを支援するAutoprefixer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/20/grunt-php/">ビルドツールGrunt.jsをPHP開発で利用する</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/07/phonegap/">Cordovaからハードウェア機能を利用する</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
